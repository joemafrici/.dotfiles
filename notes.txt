Virtual Memory Advantages
    Each process has different memory mapping - memory protection between processes
    Kernal RAM is not visible to user space processes

    Memory can be moved
    Memory can be swapped to disk

Page Fault - CPU exception generated when software attempts to use invalid Virtual Address
    The virtual address is not mapped for the process requesting it
    The process does not have the right permissions for the address
      Do we terminate process if this occurs?
    The address is valid, but swapped out

Page size 4KB
Page is a unit of memory
Page frame is a block of physical memory

Kernel refers to memory with the page number and an offset into the frame

On demand memory

Memory consists of a large array of bytes, each with its own address

Currently Stackl uses a base and limit register for memory management
The base register is the starting point in memory that the process has access to
the limit register is the total amount of memory the process has access to
The base + the limit is the top end of memory that the process can access

We need to decide if the system memory will use the base + limit system or
virtual memory

Context switching - storing the state of one process from the registers
into main memory before loading th enext process's context from main memory
into the registers

To run a program it needs to be loaded into memory from disk and placed within
the context of a process

When a process terminates its memory needs to be reclaimed for use by other
processes

Logical to Physical address mapping occurs at execution time

When a process is going to be executed its pages are loaded into memory from
disk.

The CPU generates a logical address which is composed of a page number and page
offset (and other stuff). The page number is used as an index into the page
table.

The page table is a collection of entries. Each entry contains the base
address of the page frame that the entry maps to. The offset is the location in
the frame being referenced

Base address of frame + offset = physical memory address

Each process has a page table

Translate logical address generated by CPU to physical address:
  Get page number and use it as index into page table
  Get corresponding frame number from page table
  Replace page number in logical address with frame number
  Frame number and offset now comprise physical address


"The selection of a power of 2 as a page size makes the translation of a logical
address ito a page number and page offset particularly easy. If the size of the
logical address space is 2^m, and a page size is 2^n bytes, then the high-order
m-n bits of a logical address designate the page number, and the n low-order
bits designate the page offset. Thus, the logical address is as follows:

      page number         page offset
          p          |         d
        m - n        |         n
p is an index into the page table and d is the displacement within the page

"


Logical memory is organized as pages. If you wanted logical page zero you go to
page table index 0 and see that it has 1 which means you go to page frame 1 in
physical memory and that is where page zero in logical memory is stored. The
offset rolls through and allows you to access the specific physical address
within the page that you are looking for.

The operating system needs to be aware of the allocation details of physical
memory:
  Which frames are allocated
  Which frames are availabe
  Number of total frames

Store this information in a system wide data structure called a frame table.
Frame table will have one entry for each physical page frame.
The entry will indicate whether the frame is free or allocated. If it is
allocated which process it belongs to

A pointer to the array of page tables will be stored in a register. A context
switch involves just switching to the appropriate index into the array of page
tables for that process

An attempt to write to a read only page causes a trap to the operating system


